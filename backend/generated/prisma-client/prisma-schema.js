module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Actor {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  hijos(where: ActorWhereInput, orderBy: ActorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Actor!]
  celdas(where: CeldaWhereInput, orderBy: CeldaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Celda!]
}

type ActorConnection {
  pageInfo: PageInfo!
  edges: [ActorEdge]!
  aggregate: AggregateActor!
}

input ActorCreateInput {
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: ActorCreateManyInput
  celdas: CeldaCreateManyWithoutActorParentInput
}

input ActorCreateManyInput {
  create: [ActorCreateInput!]
  connect: [ActorWhereUniqueInput!]
}

input ActorCreateOneWithoutCeldasInput {
  create: ActorCreateWithoutCeldasInput
  connect: ActorWhereUniqueInput
}

input ActorCreateWithoutCeldasInput {
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: ActorCreateManyInput
}

type ActorEdge {
  node: Actor!
  cursor: String!
}

enum ActorOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  prioridad_ASC
  prioridad_DESC
  coments_ASC
  coments_DESC
  parent_ASC
  parent_DESC
}

type ActorPreviousValues {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
}

input ActorScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  coments: String
  coments_not: String
  coments_in: [String!]
  coments_not_in: [String!]
  coments_lt: String
  coments_lte: String
  coments_gt: String
  coments_gte: String
  coments_contains: String
  coments_not_contains: String
  coments_starts_with: String
  coments_not_starts_with: String
  coments_ends_with: String
  coments_not_ends_with: String
  parent: Boolean
  parent_not: Boolean
  AND: [ActorScalarWhereInput!]
  OR: [ActorScalarWhereInput!]
  NOT: [ActorScalarWhereInput!]
}

type ActorSubscriptionPayload {
  mutation: MutationType!
  node: Actor
  updatedFields: [String!]
  previousValues: ActorPreviousValues
}

input ActorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActorWhereInput
  AND: [ActorSubscriptionWhereInput!]
  OR: [ActorSubscriptionWhereInput!]
  NOT: [ActorSubscriptionWhereInput!]
}

input ActorUpdateDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: ActorUpdateManyInput
  celdas: CeldaUpdateManyWithoutActorParentInput
}

input ActorUpdateInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: ActorUpdateManyInput
  celdas: CeldaUpdateManyWithoutActorParentInput
}

input ActorUpdateManyDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
}

input ActorUpdateManyInput {
  create: [ActorCreateInput!]
  update: [ActorUpdateWithWhereUniqueNestedInput!]
  upsert: [ActorUpsertWithWhereUniqueNestedInput!]
  delete: [ActorWhereUniqueInput!]
  connect: [ActorWhereUniqueInput!]
  set: [ActorWhereUniqueInput!]
  disconnect: [ActorWhereUniqueInput!]
  deleteMany: [ActorScalarWhereInput!]
  updateMany: [ActorUpdateManyWithWhereNestedInput!]
}

input ActorUpdateManyMutationInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
}

input ActorUpdateManyWithWhereNestedInput {
  where: ActorScalarWhereInput!
  data: ActorUpdateManyDataInput!
}

input ActorUpdateOneRequiredWithoutCeldasInput {
  create: ActorCreateWithoutCeldasInput
  update: ActorUpdateWithoutCeldasDataInput
  upsert: ActorUpsertWithoutCeldasInput
  connect: ActorWhereUniqueInput
}

input ActorUpdateWithoutCeldasDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: ActorUpdateManyInput
}

input ActorUpdateWithWhereUniqueNestedInput {
  where: ActorWhereUniqueInput!
  data: ActorUpdateDataInput!
}

input ActorUpsertWithoutCeldasInput {
  update: ActorUpdateWithoutCeldasDataInput!
  create: ActorCreateWithoutCeldasInput!
}

input ActorUpsertWithWhereUniqueNestedInput {
  where: ActorWhereUniqueInput!
  update: ActorUpdateDataInput!
  create: ActorCreateInput!
}

input ActorWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  coments: String
  coments_not: String
  coments_in: [String!]
  coments_not_in: [String!]
  coments_lt: String
  coments_lte: String
  coments_gt: String
  coments_gte: String
  coments_contains: String
  coments_not_contains: String
  coments_starts_with: String
  coments_not_starts_with: String
  coments_ends_with: String
  coments_not_ends_with: String
  parent: Boolean
  parent_not: Boolean
  hijos_every: ActorWhereInput
  hijos_some: ActorWhereInput
  hijos_none: ActorWhereInput
  celdas_every: CeldaWhereInput
  celdas_some: CeldaWhereInput
  celdas_none: CeldaWhereInput
  AND: [ActorWhereInput!]
  OR: [ActorWhereInput!]
  NOT: [ActorWhereInput!]
}

input ActorWhereUniqueInput {
  id: Int
}

type AggregateActor {
  count: Int!
}

type AggregateCelda {
  count: Int!
}

type AggregateEstado {
  count: Int!
}

type AggregateMatriz {
  count: Int!
}

type AggregateTema {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Celda {
  id: ID!
  TemaParent: Tema!
  ActorParent: Actor!
  createdAt: DateTime!
  updatedAt: DateTime!
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: Matriz!
}

type CeldaConnection {
  pageInfo: PageInfo!
  edges: [CeldaEdge]!
  aggregate: AggregateCelda!
}

input CeldaCreateInput {
  id: ID
  TemaParent: TemaCreateOneWithoutCeldasInput!
  ActorParent: ActorCreateOneWithoutCeldasInput!
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: MatrizCreateOneWithoutCeldasInput!
}

input CeldaCreateManyWithoutActorParentInput {
  create: [CeldaCreateWithoutActorParentInput!]
  connect: [CeldaWhereUniqueInput!]
}

input CeldaCreateManyWithoutMatrizInput {
  create: [CeldaCreateWithoutMatrizInput!]
  connect: [CeldaWhereUniqueInput!]
}

input CeldaCreateManyWithoutTemaParentInput {
  create: [CeldaCreateWithoutTemaParentInput!]
  connect: [CeldaWhereUniqueInput!]
}

input CeldaCreateWithoutActorParentInput {
  id: ID
  TemaParent: TemaCreateOneWithoutCeldasInput!
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: MatrizCreateOneWithoutCeldasInput!
}

input CeldaCreateWithoutMatrizInput {
  id: ID
  TemaParent: TemaCreateOneWithoutCeldasInput!
  ActorParent: ActorCreateOneWithoutCeldasInput!
  prioridad: Int
  tiempo: Int
  coment: String
}

input CeldaCreateWithoutTemaParentInput {
  id: ID
  ActorParent: ActorCreateOneWithoutCeldasInput!
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: MatrizCreateOneWithoutCeldasInput!
}

type CeldaEdge {
  node: Celda!
  cursor: String!
}

enum CeldaOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  prioridad_ASC
  prioridad_DESC
  tiempo_ASC
  tiempo_DESC
  coment_ASC
  coment_DESC
}

type CeldaPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  prioridad: Int
  tiempo: Int
  coment: String
}

input CeldaScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  tiempo: Int
  tiempo_not: Int
  tiempo_in: [Int!]
  tiempo_not_in: [Int!]
  tiempo_lt: Int
  tiempo_lte: Int
  tiempo_gt: Int
  tiempo_gte: Int
  coment: String
  coment_not: String
  coment_in: [String!]
  coment_not_in: [String!]
  coment_lt: String
  coment_lte: String
  coment_gt: String
  coment_gte: String
  coment_contains: String
  coment_not_contains: String
  coment_starts_with: String
  coment_not_starts_with: String
  coment_ends_with: String
  coment_not_ends_with: String
  AND: [CeldaScalarWhereInput!]
  OR: [CeldaScalarWhereInput!]
  NOT: [CeldaScalarWhereInput!]
}

type CeldaSubscriptionPayload {
  mutation: MutationType!
  node: Celda
  updatedFields: [String!]
  previousValues: CeldaPreviousValues
}

input CeldaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CeldaWhereInput
  AND: [CeldaSubscriptionWhereInput!]
  OR: [CeldaSubscriptionWhereInput!]
  NOT: [CeldaSubscriptionWhereInput!]
}

input CeldaUpdateInput {
  TemaParent: TemaUpdateOneRequiredWithoutCeldasInput
  ActorParent: ActorUpdateOneRequiredWithoutCeldasInput
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: MatrizUpdateOneRequiredWithoutCeldasInput
}

input CeldaUpdateManyDataInput {
  prioridad: Int
  tiempo: Int
  coment: String
}

input CeldaUpdateManyMutationInput {
  prioridad: Int
  tiempo: Int
  coment: String
}

input CeldaUpdateManyWithoutActorParentInput {
  create: [CeldaCreateWithoutActorParentInput!]
  delete: [CeldaWhereUniqueInput!]
  connect: [CeldaWhereUniqueInput!]
  set: [CeldaWhereUniqueInput!]
  disconnect: [CeldaWhereUniqueInput!]
  update: [CeldaUpdateWithWhereUniqueWithoutActorParentInput!]
  upsert: [CeldaUpsertWithWhereUniqueWithoutActorParentInput!]
  deleteMany: [CeldaScalarWhereInput!]
  updateMany: [CeldaUpdateManyWithWhereNestedInput!]
}

input CeldaUpdateManyWithoutMatrizInput {
  create: [CeldaCreateWithoutMatrizInput!]
  delete: [CeldaWhereUniqueInput!]
  connect: [CeldaWhereUniqueInput!]
  set: [CeldaWhereUniqueInput!]
  disconnect: [CeldaWhereUniqueInput!]
  update: [CeldaUpdateWithWhereUniqueWithoutMatrizInput!]
  upsert: [CeldaUpsertWithWhereUniqueWithoutMatrizInput!]
  deleteMany: [CeldaScalarWhereInput!]
  updateMany: [CeldaUpdateManyWithWhereNestedInput!]
}

input CeldaUpdateManyWithoutTemaParentInput {
  create: [CeldaCreateWithoutTemaParentInput!]
  delete: [CeldaWhereUniqueInput!]
  connect: [CeldaWhereUniqueInput!]
  set: [CeldaWhereUniqueInput!]
  disconnect: [CeldaWhereUniqueInput!]
  update: [CeldaUpdateWithWhereUniqueWithoutTemaParentInput!]
  upsert: [CeldaUpsertWithWhereUniqueWithoutTemaParentInput!]
  deleteMany: [CeldaScalarWhereInput!]
  updateMany: [CeldaUpdateManyWithWhereNestedInput!]
}

input CeldaUpdateManyWithWhereNestedInput {
  where: CeldaScalarWhereInput!
  data: CeldaUpdateManyDataInput!
}

input CeldaUpdateWithoutActorParentDataInput {
  TemaParent: TemaUpdateOneRequiredWithoutCeldasInput
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: MatrizUpdateOneRequiredWithoutCeldasInput
}

input CeldaUpdateWithoutMatrizDataInput {
  TemaParent: TemaUpdateOneRequiredWithoutCeldasInput
  ActorParent: ActorUpdateOneRequiredWithoutCeldasInput
  prioridad: Int
  tiempo: Int
  coment: String
}

input CeldaUpdateWithoutTemaParentDataInput {
  ActorParent: ActorUpdateOneRequiredWithoutCeldasInput
  prioridad: Int
  tiempo: Int
  coment: String
  matriz: MatrizUpdateOneRequiredWithoutCeldasInput
}

input CeldaUpdateWithWhereUniqueWithoutActorParentInput {
  where: CeldaWhereUniqueInput!
  data: CeldaUpdateWithoutActorParentDataInput!
}

input CeldaUpdateWithWhereUniqueWithoutMatrizInput {
  where: CeldaWhereUniqueInput!
  data: CeldaUpdateWithoutMatrizDataInput!
}

input CeldaUpdateWithWhereUniqueWithoutTemaParentInput {
  where: CeldaWhereUniqueInput!
  data: CeldaUpdateWithoutTemaParentDataInput!
}

input CeldaUpsertWithWhereUniqueWithoutActorParentInput {
  where: CeldaWhereUniqueInput!
  update: CeldaUpdateWithoutActorParentDataInput!
  create: CeldaCreateWithoutActorParentInput!
}

input CeldaUpsertWithWhereUniqueWithoutMatrizInput {
  where: CeldaWhereUniqueInput!
  update: CeldaUpdateWithoutMatrizDataInput!
  create: CeldaCreateWithoutMatrizInput!
}

input CeldaUpsertWithWhereUniqueWithoutTemaParentInput {
  where: CeldaWhereUniqueInput!
  update: CeldaUpdateWithoutTemaParentDataInput!
  create: CeldaCreateWithoutTemaParentInput!
}

input CeldaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  TemaParent: TemaWhereInput
  ActorParent: ActorWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  tiempo: Int
  tiempo_not: Int
  tiempo_in: [Int!]
  tiempo_not_in: [Int!]
  tiempo_lt: Int
  tiempo_lte: Int
  tiempo_gt: Int
  tiempo_gte: Int
  coment: String
  coment_not: String
  coment_in: [String!]
  coment_not_in: [String!]
  coment_lt: String
  coment_lte: String
  coment_gt: String
  coment_gte: String
  coment_contains: String
  coment_not_contains: String
  coment_starts_with: String
  coment_not_starts_with: String
  coment_ends_with: String
  coment_not_ends_with: String
  matriz: MatrizWhereInput
  AND: [CeldaWhereInput!]
  OR: [CeldaWhereInput!]
  NOT: [CeldaWhereInput!]
}

input CeldaWhereUniqueInput {
  id: ID
}

scalar DateTime

type Estado {
  id: ID!
  NumActor: Int!
  NumTemas: Int!
}

type EstadoConnection {
  pageInfo: PageInfo!
  edges: [EstadoEdge]!
  aggregate: AggregateEstado!
}

input EstadoCreateInput {
  id: ID
  NumActor: Int!
  NumTemas: Int!
}

type EstadoEdge {
  node: Estado!
  cursor: String!
}

enum EstadoOrderByInput {
  id_ASC
  id_DESC
  NumActor_ASC
  NumActor_DESC
  NumTemas_ASC
  NumTemas_DESC
}

type EstadoPreviousValues {
  id: ID!
  NumActor: Int!
  NumTemas: Int!
}

type EstadoSubscriptionPayload {
  mutation: MutationType!
  node: Estado
  updatedFields: [String!]
  previousValues: EstadoPreviousValues
}

input EstadoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EstadoWhereInput
  AND: [EstadoSubscriptionWhereInput!]
  OR: [EstadoSubscriptionWhereInput!]
  NOT: [EstadoSubscriptionWhereInput!]
}

input EstadoUpdateInput {
  NumActor: Int
  NumTemas: Int
}

input EstadoUpdateManyMutationInput {
  NumActor: Int
  NumTemas: Int
}

input EstadoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  NumActor: Int
  NumActor_not: Int
  NumActor_in: [Int!]
  NumActor_not_in: [Int!]
  NumActor_lt: Int
  NumActor_lte: Int
  NumActor_gt: Int
  NumActor_gte: Int
  NumTemas: Int
  NumTemas_not: Int
  NumTemas_in: [Int!]
  NumTemas_not_in: [Int!]
  NumTemas_lt: Int
  NumTemas_lte: Int
  NumTemas_gt: Int
  NumTemas_gte: Int
  AND: [EstadoWhereInput!]
  OR: [EstadoWhereInput!]
  NOT: [EstadoWhereInput!]
}

input EstadoWhereUniqueInput {
  id: ID
}

scalar Long

type Matriz {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  User: User
  Actores(where: ActorWhereInput, orderBy: ActorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Actor!]
  Temas(where: TemaWhereInput, orderBy: TemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tema!]
  Celdas(where: CeldaWhereInput, orderBy: CeldaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Celda!]
}

type MatrizConnection {
  pageInfo: PageInfo!
  edges: [MatrizEdge]!
  aggregate: AggregateMatriz!
}

input MatrizCreateInput {
  id: ID
  User: UserCreateOneInput
  Actores: ActorCreateManyInput
  Temas: TemaCreateManyInput
  Celdas: CeldaCreateManyWithoutMatrizInput
}

input MatrizCreateOneWithoutCeldasInput {
  create: MatrizCreateWithoutCeldasInput
  connect: MatrizWhereUniqueInput
}

input MatrizCreateWithoutCeldasInput {
  id: ID
  User: UserCreateOneInput
  Actores: ActorCreateManyInput
  Temas: TemaCreateManyInput
}

type MatrizEdge {
  node: Matriz!
  cursor: String!
}

enum MatrizOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MatrizPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MatrizSubscriptionPayload {
  mutation: MutationType!
  node: Matriz
  updatedFields: [String!]
  previousValues: MatrizPreviousValues
}

input MatrizSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatrizWhereInput
  AND: [MatrizSubscriptionWhereInput!]
  OR: [MatrizSubscriptionWhereInput!]
  NOT: [MatrizSubscriptionWhereInput!]
}

input MatrizUpdateInput {
  User: UserUpdateOneInput
  Actores: ActorUpdateManyInput
  Temas: TemaUpdateManyInput
  Celdas: CeldaUpdateManyWithoutMatrizInput
}

input MatrizUpdateOneRequiredWithoutCeldasInput {
  create: MatrizCreateWithoutCeldasInput
  update: MatrizUpdateWithoutCeldasDataInput
  upsert: MatrizUpsertWithoutCeldasInput
  connect: MatrizWhereUniqueInput
}

input MatrizUpdateWithoutCeldasDataInput {
  User: UserUpdateOneInput
  Actores: ActorUpdateManyInput
  Temas: TemaUpdateManyInput
}

input MatrizUpsertWithoutCeldasInput {
  update: MatrizUpdateWithoutCeldasDataInput!
  create: MatrizCreateWithoutCeldasInput!
}

input MatrizWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  User: UserWhereInput
  Actores_every: ActorWhereInput
  Actores_some: ActorWhereInput
  Actores_none: ActorWhereInput
  Temas_every: TemaWhereInput
  Temas_some: TemaWhereInput
  Temas_none: TemaWhereInput
  Celdas_every: CeldaWhereInput
  Celdas_some: CeldaWhereInput
  Celdas_none: CeldaWhereInput
  AND: [MatrizWhereInput!]
  OR: [MatrizWhereInput!]
  NOT: [MatrizWhereInput!]
}

input MatrizWhereUniqueInput {
  id: ID
}

type Mutation {
  createActor(data: ActorCreateInput!): Actor!
  updateActor(data: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor
  updateManyActors(data: ActorUpdateManyMutationInput!, where: ActorWhereInput): BatchPayload!
  upsertActor(where: ActorWhereUniqueInput!, create: ActorCreateInput!, update: ActorUpdateInput!): Actor!
  deleteActor(where: ActorWhereUniqueInput!): Actor
  deleteManyActors(where: ActorWhereInput): BatchPayload!
  createCelda(data: CeldaCreateInput!): Celda!
  updateCelda(data: CeldaUpdateInput!, where: CeldaWhereUniqueInput!): Celda
  updateManyCeldas(data: CeldaUpdateManyMutationInput!, where: CeldaWhereInput): BatchPayload!
  upsertCelda(where: CeldaWhereUniqueInput!, create: CeldaCreateInput!, update: CeldaUpdateInput!): Celda!
  deleteCelda(where: CeldaWhereUniqueInput!): Celda
  deleteManyCeldas(where: CeldaWhereInput): BatchPayload!
  createEstado(data: EstadoCreateInput!): Estado!
  updateEstado(data: EstadoUpdateInput!, where: EstadoWhereUniqueInput!): Estado
  updateManyEstadoes(data: EstadoUpdateManyMutationInput!, where: EstadoWhereInput): BatchPayload!
  upsertEstado(where: EstadoWhereUniqueInput!, create: EstadoCreateInput!, update: EstadoUpdateInput!): Estado!
  deleteEstado(where: EstadoWhereUniqueInput!): Estado
  deleteManyEstadoes(where: EstadoWhereInput): BatchPayload!
  createMatriz(data: MatrizCreateInput!): Matriz!
  updateMatriz(data: MatrizUpdateInput!, where: MatrizWhereUniqueInput!): Matriz
  upsertMatriz(where: MatrizWhereUniqueInput!, create: MatrizCreateInput!, update: MatrizUpdateInput!): Matriz!
  deleteMatriz(where: MatrizWhereUniqueInput!): Matriz
  deleteManyMatrizes(where: MatrizWhereInput): BatchPayload!
  createTema(data: TemaCreateInput!): Tema!
  updateTema(data: TemaUpdateInput!, where: TemaWhereUniqueInput!): Tema
  updateManyTemas(data: TemaUpdateManyMutationInput!, where: TemaWhereInput): BatchPayload!
  upsertTema(where: TemaWhereUniqueInput!, create: TemaCreateInput!, update: TemaUpdateInput!): Tema!
  deleteTema(where: TemaWhereUniqueInput!): Tema
  deleteManyTemas(where: TemaWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  actor(where: ActorWhereUniqueInput!): Actor
  actors(where: ActorWhereInput, orderBy: ActorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Actor]!
  actorsConnection(where: ActorWhereInput, orderBy: ActorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActorConnection!
  celda(where: CeldaWhereUniqueInput!): Celda
  celdas(where: CeldaWhereInput, orderBy: CeldaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Celda]!
  celdasConnection(where: CeldaWhereInput, orderBy: CeldaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CeldaConnection!
  estado(where: EstadoWhereUniqueInput!): Estado
  estadoes(where: EstadoWhereInput, orderBy: EstadoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Estado]!
  estadoesConnection(where: EstadoWhereInput, orderBy: EstadoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EstadoConnection!
  matriz(where: MatrizWhereUniqueInput!): Matriz
  matrizes(where: MatrizWhereInput, orderBy: MatrizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Matriz]!
  matrizesConnection(where: MatrizWhereInput, orderBy: MatrizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatrizConnection!
  tema(where: TemaWhereUniqueInput!): Tema
  temas(where: TemaWhereInput, orderBy: TemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tema]!
  temasConnection(where: TemaWhereInput, orderBy: TemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemaConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  actor(where: ActorSubscriptionWhereInput): ActorSubscriptionPayload
  celda(where: CeldaSubscriptionWhereInput): CeldaSubscriptionPayload
  estado(where: EstadoSubscriptionWhereInput): EstadoSubscriptionPayload
  matriz(where: MatrizSubscriptionWhereInput): MatrizSubscriptionPayload
  tema(where: TemaSubscriptionWhereInput): TemaSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tema {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  hijos(where: TemaWhereInput, orderBy: TemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tema!]
  celdas(where: CeldaWhereInput, orderBy: CeldaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Celda!]
}

type TemaConnection {
  pageInfo: PageInfo!
  edges: [TemaEdge]!
  aggregate: AggregateTema!
}

input TemaCreateInput {
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: TemaCreateManyWithoutHijosInput
  celdas: CeldaCreateManyWithoutTemaParentInput
}

input TemaCreateManyInput {
  create: [TemaCreateInput!]
  connect: [TemaWhereUniqueInput!]
}

input TemaCreateManyWithoutHijosInput {
  create: [TemaCreateWithoutHijosInput!]
  connect: [TemaWhereUniqueInput!]
}

input TemaCreateOneWithoutCeldasInput {
  create: TemaCreateWithoutCeldasInput
  connect: TemaWhereUniqueInput
}

input TemaCreateWithoutCeldasInput {
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: TemaCreateManyWithoutHijosInput
}

input TemaCreateWithoutHijosInput {
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
  celdas: CeldaCreateManyWithoutTemaParentInput
}

type TemaEdge {
  node: Tema!
  cursor: String!
}

enum TemaOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  prioridad_ASC
  prioridad_DESC
  coments_ASC
  coments_DESC
  parent_ASC
  parent_DESC
}

type TemaPreviousValues {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
  parent: Boolean
}

input TemaScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  coments: String
  coments_not: String
  coments_in: [String!]
  coments_not_in: [String!]
  coments_lt: String
  coments_lte: String
  coments_gt: String
  coments_gte: String
  coments_contains: String
  coments_not_contains: String
  coments_starts_with: String
  coments_not_starts_with: String
  coments_ends_with: String
  coments_not_ends_with: String
  parent: Boolean
  parent_not: Boolean
  AND: [TemaScalarWhereInput!]
  OR: [TemaScalarWhereInput!]
  NOT: [TemaScalarWhereInput!]
}

type TemaSubscriptionPayload {
  mutation: MutationType!
  node: Tema
  updatedFields: [String!]
  previousValues: TemaPreviousValues
}

input TemaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemaWhereInput
  AND: [TemaSubscriptionWhereInput!]
  OR: [TemaSubscriptionWhereInput!]
  NOT: [TemaSubscriptionWhereInput!]
}

input TemaUpdateDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: TemaUpdateManyWithoutHijosInput
  celdas: CeldaUpdateManyWithoutTemaParentInput
}

input TemaUpdateInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: TemaUpdateManyWithoutHijosInput
  celdas: CeldaUpdateManyWithoutTemaParentInput
}

input TemaUpdateManyDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
}

input TemaUpdateManyInput {
  create: [TemaCreateInput!]
  update: [TemaUpdateWithWhereUniqueNestedInput!]
  upsert: [TemaUpsertWithWhereUniqueNestedInput!]
  delete: [TemaWhereUniqueInput!]
  connect: [TemaWhereUniqueInput!]
  set: [TemaWhereUniqueInput!]
  disconnect: [TemaWhereUniqueInput!]
  deleteMany: [TemaScalarWhereInput!]
  updateMany: [TemaUpdateManyWithWhereNestedInput!]
}

input TemaUpdateManyMutationInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
}

input TemaUpdateManyWithoutHijosInput {
  create: [TemaCreateWithoutHijosInput!]
  delete: [TemaWhereUniqueInput!]
  connect: [TemaWhereUniqueInput!]
  set: [TemaWhereUniqueInput!]
  disconnect: [TemaWhereUniqueInput!]
  update: [TemaUpdateWithWhereUniqueWithoutHijosInput!]
  upsert: [TemaUpsertWithWhereUniqueWithoutHijosInput!]
  deleteMany: [TemaScalarWhereInput!]
  updateMany: [TemaUpdateManyWithWhereNestedInput!]
}

input TemaUpdateManyWithWhereNestedInput {
  where: TemaScalarWhereInput!
  data: TemaUpdateManyDataInput!
}

input TemaUpdateOneRequiredWithoutCeldasInput {
  create: TemaCreateWithoutCeldasInput
  update: TemaUpdateWithoutCeldasDataInput
  upsert: TemaUpsertWithoutCeldasInput
  connect: TemaWhereUniqueInput
}

input TemaUpdateWithoutCeldasDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  hijos: TemaUpdateManyWithoutHijosInput
}

input TemaUpdateWithoutHijosDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: Boolean
  celdas: CeldaUpdateManyWithoutTemaParentInput
}

input TemaUpdateWithWhereUniqueNestedInput {
  where: TemaWhereUniqueInput!
  data: TemaUpdateDataInput!
}

input TemaUpdateWithWhereUniqueWithoutHijosInput {
  where: TemaWhereUniqueInput!
  data: TemaUpdateWithoutHijosDataInput!
}

input TemaUpsertWithoutCeldasInput {
  update: TemaUpdateWithoutCeldasDataInput!
  create: TemaCreateWithoutCeldasInput!
}

input TemaUpsertWithWhereUniqueNestedInput {
  where: TemaWhereUniqueInput!
  update: TemaUpdateDataInput!
  create: TemaCreateInput!
}

input TemaUpsertWithWhereUniqueWithoutHijosInput {
  where: TemaWhereUniqueInput!
  update: TemaUpdateWithoutHijosDataInput!
  create: TemaCreateWithoutHijosInput!
}

input TemaWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  coments: String
  coments_not: String
  coments_in: [String!]
  coments_not_in: [String!]
  coments_lt: String
  coments_lte: String
  coments_gt: String
  coments_gte: String
  coments_contains: String
  coments_not_contains: String
  coments_starts_with: String
  coments_not_starts_with: String
  coments_ends_with: String
  coments_not_ends_with: String
  parent: Boolean
  parent_not: Boolean
  hijos_every: TemaWhereInput
  hijos_some: TemaWhereInput
  hijos_none: TemaWhereInput
  celdas_every: CeldaWhereInput
  celdas_some: CeldaWhereInput
  celdas_none: CeldaWhereInput
  AND: [TemaWhereInput!]
  OR: [TemaWhereInput!]
  NOT: [TemaWhereInput!]
}

input TemaWhereUniqueInput {
  id: Int
}

type User {
  id: ID!
  name: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
}

input UserUpdateInput {
  name: String
}

input UserUpdateManyMutationInput {
  name: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    