module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Actor {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
  parent: Actor
}

type ActorConnection {
  pageInfo: PageInfo!
  edges: [ActorEdge]!
  aggregate: AggregateActor!
}

input ActorCreateInput {
  name: String!
  prioridad: Int
  coments: String
  parent: ActorCreateOneInput
}

input ActorCreateOneInput {
  create: ActorCreateInput
  connect: ActorWhereUniqueInput
}

type ActorEdge {
  node: Actor!
  cursor: String!
}

enum ActorOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  prioridad_ASC
  prioridad_DESC
  coments_ASC
  coments_DESC
}

type ActorPreviousValues {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
}

type ActorSubscriptionPayload {
  mutation: MutationType!
  node: Actor
  updatedFields: [String!]
  previousValues: ActorPreviousValues
}

input ActorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActorWhereInput
  AND: [ActorSubscriptionWhereInput!]
  OR: [ActorSubscriptionWhereInput!]
  NOT: [ActorSubscriptionWhereInput!]
}

input ActorUpdateDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: ActorUpdateOneInput
}

input ActorUpdateInput {
  name: String
  prioridad: Int
  coments: String
  parent: ActorUpdateOneInput
}

input ActorUpdateManyMutationInput {
  name: String
  prioridad: Int
  coments: String
}

input ActorUpdateOneInput {
  create: ActorCreateInput
  update: ActorUpdateDataInput
  upsert: ActorUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ActorWhereUniqueInput
}

input ActorUpsertNestedInput {
  update: ActorUpdateDataInput!
  create: ActorCreateInput!
}

input ActorWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  coments: String
  coments_not: String
  coments_in: [String!]
  coments_not_in: [String!]
  coments_lt: String
  coments_lte: String
  coments_gt: String
  coments_gte: String
  coments_contains: String
  coments_not_contains: String
  coments_starts_with: String
  coments_not_starts_with: String
  coments_ends_with: String
  coments_not_ends_with: String
  parent: ActorWhereInput
  AND: [ActorWhereInput!]
  OR: [ActorWhereInput!]
  NOT: [ActorWhereInput!]
}

input ActorWhereUniqueInput {
  id: Int
}

type AggregateActor {
  count: Int!
}

type AggregateLink {
  count: Int!
}

type AggregateTema {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Link {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  url: String!
}

type LinkConnection {
  pageInfo: PageInfo!
  edges: [LinkEdge]!
  aggregate: AggregateLink!
}

input LinkCreateInput {
  id: ID
  description: String!
  url: String!
}

type LinkEdge {
  node: Link!
  cursor: String!
}

enum LinkOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  description_ASC
  description_DESC
  url_ASC
  url_DESC
}

type LinkPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  url: String!
}

type LinkSubscriptionPayload {
  mutation: MutationType!
  node: Link
  updatedFields: [String!]
  previousValues: LinkPreviousValues
}

input LinkSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LinkWhereInput
  AND: [LinkSubscriptionWhereInput!]
  OR: [LinkSubscriptionWhereInput!]
  NOT: [LinkSubscriptionWhereInput!]
}

input LinkUpdateInput {
  description: String
  url: String
}

input LinkUpdateManyMutationInput {
  description: String
  url: String
}

input LinkWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [LinkWhereInput!]
  OR: [LinkWhereInput!]
  NOT: [LinkWhereInput!]
}

input LinkWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createActor(data: ActorCreateInput!): Actor!
  updateActor(data: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor
  updateManyActors(data: ActorUpdateManyMutationInput!, where: ActorWhereInput): BatchPayload!
  upsertActor(where: ActorWhereUniqueInput!, create: ActorCreateInput!, update: ActorUpdateInput!): Actor!
  deleteActor(where: ActorWhereUniqueInput!): Actor
  deleteManyActors(where: ActorWhereInput): BatchPayload!
  createLink(data: LinkCreateInput!): Link!
  updateLink(data: LinkUpdateInput!, where: LinkWhereUniqueInput!): Link
  updateManyLinks(data: LinkUpdateManyMutationInput!, where: LinkWhereInput): BatchPayload!
  upsertLink(where: LinkWhereUniqueInput!, create: LinkCreateInput!, update: LinkUpdateInput!): Link!
  deleteLink(where: LinkWhereUniqueInput!): Link
  deleteManyLinks(where: LinkWhereInput): BatchPayload!
  createTema(data: TemaCreateInput!): Tema!
  updateTema(data: TemaUpdateInput!, where: TemaWhereUniqueInput!): Tema
  updateManyTemas(data: TemaUpdateManyMutationInput!, where: TemaWhereInput): BatchPayload!
  upsertTema(where: TemaWhereUniqueInput!, create: TemaCreateInput!, update: TemaUpdateInput!): Tema!
  deleteTema(where: TemaWhereUniqueInput!): Tema
  deleteManyTemas(where: TemaWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  actor(where: ActorWhereUniqueInput!): Actor
  actors(where: ActorWhereInput, orderBy: ActorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Actor]!
  actorsConnection(where: ActorWhereInput, orderBy: ActorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActorConnection!
  link(where: LinkWhereUniqueInput!): Link
  links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link]!
  linksConnection(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LinkConnection!
  tema(where: TemaWhereUniqueInput!): Tema
  temas(where: TemaWhereInput, orderBy: TemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tema]!
  temasConnection(where: TemaWhereInput, orderBy: TemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemaConnection!
  node(id: ID!): Node
}

type Subscription {
  actor(where: ActorSubscriptionWhereInput): ActorSubscriptionPayload
  link(where: LinkSubscriptionWhereInput): LinkSubscriptionPayload
  tema(where: TemaSubscriptionWhereInput): TemaSubscriptionPayload
}

type Tema {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
  parent: Tema
}

type TemaConnection {
  pageInfo: PageInfo!
  edges: [TemaEdge]!
  aggregate: AggregateTema!
}

input TemaCreateInput {
  name: String!
  prioridad: Int
  coments: String
  parent: TemaCreateOneInput
}

input TemaCreateOneInput {
  create: TemaCreateInput
  connect: TemaWhereUniqueInput
}

type TemaEdge {
  node: Tema!
  cursor: String!
}

enum TemaOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  prioridad_ASC
  prioridad_DESC
  coments_ASC
  coments_DESC
}

type TemaPreviousValues {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  prioridad: Int
  coments: String
}

type TemaSubscriptionPayload {
  mutation: MutationType!
  node: Tema
  updatedFields: [String!]
  previousValues: TemaPreviousValues
}

input TemaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemaWhereInput
  AND: [TemaSubscriptionWhereInput!]
  OR: [TemaSubscriptionWhereInput!]
  NOT: [TemaSubscriptionWhereInput!]
}

input TemaUpdateDataInput {
  name: String
  prioridad: Int
  coments: String
  parent: TemaUpdateOneInput
}

input TemaUpdateInput {
  name: String
  prioridad: Int
  coments: String
  parent: TemaUpdateOneInput
}

input TemaUpdateManyMutationInput {
  name: String
  prioridad: Int
  coments: String
}

input TemaUpdateOneInput {
  create: TemaCreateInput
  update: TemaUpdateDataInput
  upsert: TemaUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TemaWhereUniqueInput
}

input TemaUpsertNestedInput {
  update: TemaUpdateDataInput!
  create: TemaCreateInput!
}

input TemaWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prioridad: Int
  prioridad_not: Int
  prioridad_in: [Int!]
  prioridad_not_in: [Int!]
  prioridad_lt: Int
  prioridad_lte: Int
  prioridad_gt: Int
  prioridad_gte: Int
  coments: String
  coments_not: String
  coments_in: [String!]
  coments_not_in: [String!]
  coments_lt: String
  coments_lte: String
  coments_gt: String
  coments_gte: String
  coments_contains: String
  coments_not_contains: String
  coments_starts_with: String
  coments_not_starts_with: String
  coments_ends_with: String
  coments_not_ends_with: String
  parent: TemaWhereInput
  AND: [TemaWhereInput!]
  OR: [TemaWhereInput!]
  NOT: [TemaWhereInput!]
}

input TemaWhereUniqueInput {
  id: Int
}
`
      }
    